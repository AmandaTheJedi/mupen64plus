#summary How to install and run Mupen64Plus on Intel Macintosh computers with OSX

Here are some basic usage instructions for !Mupen64Plus on Intel Macintosh computers with OSX.  As of October, 2008, all of the !Mupen64Plus software will compile and run, however there are some known problems with input and audio.  Please be aware that !Mupen64Plus does not currently run on older PowerPC based Macintosh computers.

Please note that these instructions are meant as guidelines for people who know what they're doing. If you don't have much experience building stuff from source, I would recommend that you wait for binary packages instead.

==ENVIRONMENT==
 * Install developer tools (Xcode) from the DVD that came with your Mac.


==GETTING MUPEN64PLUS==
You can simply download a source archive from the mupen64plus website; you can also use SVN. SVN example :
{{{
mkdir mupen64plus
cd mupen64plus
svn co svn://fascination.homelinux.net:7684/mupen64plus/trunk --username mupen64 --password Dyson5632-kart
}}}

==DEPENDENCIES==
 * Mupen can be built with either GTK+ or Qt. It is expected that in the future the Qt version will work better, but until then the GTK+ version is easier to get to run. Install GTK+ from http://www.gtk-osx.org/. (If you like using macports, beware : GTK as installed from macports _will_ work on your computer, but you won't be able to package a distributable dmg. The installer from the website mentionned is much more handy for this)
 
 * Other dependencies can be installed either from source or from macports.

===(A) THE SOURCE CODE WAY===
You will need SDL, SDL_ttf and its subdependencies (Freetype, fontconfig), and libpng.
Find them with [http://www.google.com Google] and install them with the usual
{{{
./configure
make
sudo make install
}}}

===(B) THE MACPORTS WAY===
 * Install macports from [http://www.macports.org/install.php macports.org]
 * Open terminal (under Hard Drive, Applications, Utilities, Terminal). Type in the following commands.
{{{
sudo port install libsdl_ttf libpng
}}}

Since macports installs librairies in a non-standard prefix, you will need to help the makefiles find librairies installed from macports. You can simply export LDFLAGS=-L/opt/local/lib or, more conveniently, change it on a more permanent basis by editing *pre.mk* in the mupen source - then locate the lines that read
{{{
OS = OSX
LDFLAGS += -liconv -lpng
}}}
and make the second one
{{{
LDFLAGS += -L/opt/local/lib -liconv -lpng
}}}


==BUILDING MUPEN64PLUS==
We'll first set some environment variables to help mupen find GTK+. Also make sure sdl-config is in your PATH.
{{{
export PKG_CONFIG_PATH=/Library/Frameworks/Gtk.framework/Resources/dev/lib/pkgconfig
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/Library/Frameworks/GLib.framework/Resources/dev/lib/pkgconfig
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/Library/Frameworks/Cairo.framework/Resources/dev/lib/pkgconfig 
}}}
Then cross your fingers, it's time to build!
{{{
cd /path/to/mupen/trunk
make all
}}}

Or, for a debug build:
{{{
make DBGSYM=1 all
}}}

==RUNNING==
{{{
cd mupen64plus/trunk/
./mupen64plus
}}}

To run no gui mode :
{{{
# simplest :
./mupen64plus --nogui <rom-path>

# pass some settings
./mupen64plus --nogui --gfx plugins/glN64.so --audio plugins/jttl_audio.so --input plugins/blight_input.so --rsp plugins/mupen64_hle_rsp_azimer.so --emumode 1 <rom-path>
}}}

==PACKAGING MUPEN64PLUS==
If all you wanted is to play with !Mupen64Plus, this section won't apply to you; but we want to share the fun with others, don't we? From now on, I'll concentrate on how to build a package you can send to others.

Start by installing mupen :
{{{
sudo ./install.sh
}}}

You will first need an *Info.plist* file, sample here :
{{{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key> <string>English</string>
	<key>CFBundleInfoDictionaryVersion</key> <string>6.0</string>
	<key>CFBundlePackageType</key> <string>APPL</string>
	<key>CSResourcesFileMapped</key>  <true/>

	<key>CFBundleExecutable</key>  <string>launcher</string>
	<key>CFBundleName</key>        <string>Mupen64Plus</string>
	<key>CFBundleIconFile</key>    <string>mupen64plus.icns</string>
	<key>CFBundleVersion</key>     <string>1.5</string>
	
		
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>n64</string>
				<string>N64</string>
				<string>z64</string>
				<string>V64</string>
				<string>v64</string>
				<string>V64</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>mupen64cart.icns</string>
			<key>CFBundleTypeName</key>
			<string>N64 Rom</string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>LSIsAppleDefaultForType</key>
			<true/>
			<key>LSTypeIsPackage</key>
			<false/>
		</dict>
		
	</array>
	
</dict>
</plist>
}}}
(note that the executable name in this Info.plist file is _launcher_ - I'll explain why below)

You will also need icons for mupen and ROMs : mupen64plus.icns, mupen64cart.icns

Then you can build the application bundle by using a simple shell script :
{{{
INSTALL_PREFIX="/usr/local"
APP_CONTENTS="./Mupen64Plus.app/Contents"

echo "* Removing any existing installation"
rm -rf ./Mupen64Plus.app

echo "* Creating skeleton"
mkdir -p $APP_CONTENTS/Resources
mkdir $APP_CONTENTS/MacOS
cp Info.plist $APP_CONTENTS/Info.plist
cp mupen64plus.icns $APP_CONTENTS/Resources/mupen64plus.icns
cp mupen64cart.icns $APP_CONTENTS/Resources/mupen64cart.icns

echo "* Copying executable"
cp $INSTALL_PREFIX/bin/mupen64plus $APP_CONTENTS/MacOS/mupen64plus
#cp ./launcher $APP_CONTENTS/MacOS/launcher

echo "* Copying data files"
cp -r $INSTALL_PREFIX/share/mupen64plus/ $APP_CONTENTS/Resources/
}}}

You can then make this bundle distributable by blessing it with [http://macdylibbundler.sourceforge.net DylibBundler]. First install DylibBundler by following the instructions inside. Then run this small script :

{{{
APP_CONTENTS="./Mupen64Plus.app/Contents"

FIX_LIST="-x $APP_CONTENTS/MacOS/mupen64plus \
-x $APP_CONTENTS/Resources/plugins/blight_input.so \
-x $APP_CONTENTS/Resources/plugins/dummyaudio.so \
-x $APP_CONTENTS/Resources/plugins/dummyvideo.so \
-x $APP_CONTENTS/Resources/plugins/glide64.so \
-x $APP_CONTENTS/Resources/plugins/glN64.so \
-x $APP_CONTENTS/Resources/plugins/jttl_audio.so \
-x $APP_CONTENTS/Resources/plugins/mupen64_hle_rsp_azimer.so \
-x $APP_CONTENTS/Resources/plugins/mupen64_input.so \
-x $APP_CONTENTS/Resources/plugins/ricevideo.so"

dylibbundler -od -b $FIX_LIST -d $APP_CONTENTS/libs/
}}}

Voila it's ready! Well actually, it should be in theory... In practice there is a bug on mac : when using both SDL and GTK+ at the same time, both grab the event loop and conflict with each other. The result of this is that ROMs cannot be launched from the GTK GUI, they can only be run in _nogui_ mode. The GTK interface however still remains necessary to configure mupen. Until this issue gets fixed properly, I work around it by placing a second executable in the bundle called _launcher_ (see the bundling script above, there is a commented out line that does this). This executable can then act as a bridge to either open the GTK GUI and configure mupen, either launch a ROM in nogui mode.

To make the launcher, I used this wxWidgets code (I can hear people asking "why not Cocoa?". Well, simply because I don't know Cocoa `^`o`^`)
{{{
#include <iostream>
#include "wx/wx.h"
#include "wx/html/webkit.h"
#include "wx/stdpaths.h"

enum
{
    ID_CONFIGURE,
    ID_LAUNCH
};

class QuickBoxLayout
{
    wxBoxSizer* bsizer;
public:
    wxPanel* pane;
    
    QuickBoxLayout(wxWindow* component, wxSizer* parent, int orientation=wxHORIZONTAL)
    {
        pane = new wxPanel(component);
        parent->Add(pane,1);
        bsizer = new wxBoxSizer(orientation);
    }
    void add(wxWindow* window)
    {
        bsizer->Add(window, 1, wxALL, 10);
    }
    ~QuickBoxLayout()
    {
        pane->SetSizer(bsizer);
        bsizer->Layout();
        //bsizer->SetSizeHints(pane);
    }
};


class MyFrame : public wxFrame
{
public:
    MyFrame(wxWindow* ptr, int id, wxString name, wxPoint pos, wxSize size) : wxFrame(ptr,id,name,pos,size)
    {
        wxBoxSizer* bsizer = new wxBoxSizer(wxHORIZONTAL);
        
        wxString filepath = wxT("file://") + wxStandardPaths::Get().GetResourcesDir() + wxT("/") + wxT("beta_msg.htm") ;
        filepath.Replace(wxT(" "), wxT("%20"));
        
        wxWebKitCtrl* html = new wxWebKitCtrl(this, wxID_ANY, filepath );
        bsizer->Add( html, 2, wxEXPAND );
        
        {
        QuickBoxLayout rightPane(this, bsizer, wxVERTICAL);
        rightPane.add( new wxButton( rightPane.pane, ID_CONFIGURE, _("Configure mupen64plus") ) );
        rightPane.add( new wxButton( rightPane.pane, ID_LAUNCH, _("Play rom") ) );
        }
        
        SetSizer(bsizer);
        Layout();
        
        Center();
        Show();
    }
    void onConfigureClicked(wxCommandEvent& evt)
    {
        wxExecute( wxStandardPaths::Get().GetResourcesDir()+wxT("/../MacOS/mupen64plus") );
    }
    void onLaunchClicked(wxCommandEvent& evt)
    {
        wxString filename = wxFileSelector( wxT("Choose a N64 ROM file") );
        if ( !filename.empty() )
        {
            wxString cmd = wxT("\"") + wxStandardPaths::Get().GetResourcesDir() + wxT("/../MacOS/mupen64plus\" --nogui \"") + filename + wxT("\"");
            std::cout << cmd.mb_str() << std::endl;
            wxExecute( cmd );
        }
        
    }
    
    DECLARE_EVENT_TABLE()
};

BEGIN_EVENT_TABLE(MyFrame, wxFrame)
EVT_BUTTON( ID_CONFIGURE, MyFrame::onConfigureClicked )
EVT_BUTTON( ID_LAUNCH,    MyFrame::onLaunchClicked )
END_EVENT_TABLE()

class MyApp: public wxApp
{
public:
    virtual bool OnInit();
    
    virtual void MacOpenFile(const wxString &filename)
    {
        wxString cmd = wxT("\"") + wxStandardPaths::Get().GetResourcesDir() + wxT("/../MacOS/mupen64plus\" --nogui \"") + filename + wxT("\"");
        std::cout << cmd.mb_str() << std::endl;
        wxExecute( cmd );
    }
};


IMPLEMENT_APP(MyApp)


bool MyApp::OnInit()
{
    wxInitAllImageHandlers();
    MyFrame* frame = new MyFrame(NULL, wxID_ANY,  wxT("Mupen 64 Plus beta launcher"), wxDefaultPosition, wxSize(750,480));
	
    return true;
}
}}}

This code can be built with something like
{{{
g++ launcher.cpp `wx-config --cxxflags --libs` -o launcher
}}}

With this launcher as main executable, plus a HTML file containing instructions as the launcher expects to find, you should finally have a distributable executable!

To be continued...

To be continued...